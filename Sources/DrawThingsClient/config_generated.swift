// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

public enum SamplerType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case dpmpp2mkarras = 0
  case eulera = 1
  case ddim = 2
  case plms = 3
  case dpmppsdekarras = 4
  case unipc = 5
  case lcm = 6
  case eulerasubstep = 7
  case dpmppsdesubstep = 8
  case tcd = 9
  case euleratrailing = 10
  case dpmppsdetrailing = 11
  case dpmpp2mays = 12
  case euleraays = 13
  case dpmppsdeays = 14
  case dpmpp2mtrailing = 15
  case ddimtrailing = 16
  case unipctrailing = 17
  case unipcays = 18

  public static var max: SamplerType { return .unipcays }
  public static var min: SamplerType { return .dpmpp2mkarras }
}


public enum SeedMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case legacy = 0
  case torchcpucompatible = 1
  case scalealike = 2
  case nvidiagpucompatible = 3

  public static var max: SeedMode { return .nvidiagpucompatible }
  public static var min: SeedMode { return .legacy }
}


public enum ControlMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case balanced = 0
  case prompt = 1
  case control = 2

  public static var max: ControlMode { return .control }
  public static var min: ControlMode { return .balanced }
}


public enum ControlInputType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unspecified = 0
  case custom = 1
  case depth = 2
  case canny = 3
  case scribble = 4
  case pose = 5
  case normalbae = 6
  case color = 7
  case lineart = 8
  case softedge = 9
  case seg = 10
  case inpaint = 11
  case ip2p = 12
  case shuffle = 13
  case mlsd = 14
  case tile = 15
  case blur = 16
  case lowquality = 17
  case gray = 18

  public static var max: ControlInputType { return .gray }
  public static var min: ControlInputType { return .unspecified }
}


public enum LoRAMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case all = 0
  case base = 1
  case refiner = 2

  public static var max: LoRAMode { return .refiner }
  public static var min: LoRAMode { return .all }
}


public struct Control: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case file = 4
    case weight = 6
    case guidanceStart = 8
    case guidanceEnd = 10
    case noPrompt = 12
    case globalAveragePooling = 14
    case downSamplingRate = 16
    case controlMode = 18
    case targetBlocks = 20
    case inputOverride = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var file: String? { let o = _accessor.offset(VTOFFSET.file.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var fileSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.file.v) }
  public var weight: Float32 { let o = _accessor.offset(VTOFFSET.weight.v); return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var guidanceStart: Float32 { let o = _accessor.offset(VTOFFSET.guidanceStart.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var guidanceEnd: Float32 { let o = _accessor.offset(VTOFFSET.guidanceEnd.v); return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var noPrompt: Bool { let o = _accessor.offset(VTOFFSET.noPrompt.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var globalAveragePooling: Bool { let o = _accessor.offset(VTOFFSET.globalAveragePooling.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  public var downSamplingRate: Float32 { let o = _accessor.offset(VTOFFSET.downSamplingRate.v); return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var controlMode: ControlMode { let o = _accessor.offset(VTOFFSET.controlMode.v); return o == 0 ? .balanced : ControlMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .balanced }
  public var hasTargetBlocks: Bool { let o = _accessor.offset(VTOFFSET.targetBlocks.v); return o == 0 ? false : true }
  public var targetBlocksCount: Int32 { let o = _accessor.offset(VTOFFSET.targetBlocks.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func targetBlocks(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.targetBlocks.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var inputOverride: ControlInputType { let o = _accessor.offset(VTOFFSET.inputOverride.v); return o == 0 ? .unspecified : ControlInputType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unspecified }
  public static func startControl(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(file: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: file, at: VTOFFSET.file.p) }
  public static func add(weight: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: weight, def: 1.0, at: VTOFFSET.weight.p) }
  public static func add(guidanceStart: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: guidanceStart, def: 0.0, at: VTOFFSET.guidanceStart.p) }
  public static func add(guidanceEnd: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: guidanceEnd, def: 1.0, at: VTOFFSET.guidanceEnd.p) }
  public static func add(noPrompt: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: noPrompt, def: false,
   at: VTOFFSET.noPrompt.p) }
  public static func add(globalAveragePooling: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: globalAveragePooling, def: true,
   at: VTOFFSET.globalAveragePooling.p) }
  public static func add(downSamplingRate: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: downSamplingRate, def: 1.0, at: VTOFFSET.downSamplingRate.p) }
  public static func add(controlMode: ControlMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: controlMode.rawValue, def: 0, at: VTOFFSET.controlMode.p) }
  public static func addVectorOf(targetBlocks: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: targetBlocks, at: VTOFFSET.targetBlocks.p) }
  public static func add(inputOverride: ControlInputType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: inputOverride.rawValue, def: 0, at: VTOFFSET.inputOverride.p) }
  public static func endControl(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createControl(
    _ fbb: inout FlatBufferBuilder,
    fileOffset file: Offset = Offset(),
    weight: Float32 = 1.0,
    guidanceStart: Float32 = 0.0,
    guidanceEnd: Float32 = 1.0,
    noPrompt: Bool = false,
    globalAveragePooling: Bool = true,
    downSamplingRate: Float32 = 1.0,
    controlMode: ControlMode = .balanced,
    targetBlocksVectorOffset targetBlocks: Offset = Offset(),
    inputOverride: ControlInputType = .unspecified
  ) -> Offset {
    let __start = Control.startControl(&fbb)
    Control.add(file: file, &fbb)
    Control.add(weight: weight, &fbb)
    Control.add(guidanceStart: guidanceStart, &fbb)
    Control.add(guidanceEnd: guidanceEnd, &fbb)
    Control.add(noPrompt: noPrompt, &fbb)
    Control.add(globalAveragePooling: globalAveragePooling, &fbb)
    Control.add(downSamplingRate: downSamplingRate, &fbb)
    Control.add(controlMode: controlMode, &fbb)
    Control.addVectorOf(targetBlocks: targetBlocks, &fbb)
    Control.add(inputOverride: inputOverride, &fbb)
    return Control.endControl(&fbb, start: __start)
  }
  

  public mutating func unpack() -> ControlT {
    return ControlT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout ControlT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout ControlT) -> Offset {
    let __file: Offset
    if let s = obj.file {
      __file = builder.create(string: s)
    } else {
      __file = Offset()
    }

    let __targetBlocks = builder.createVector(ofStrings: obj.targetBlocks.compactMap({ $0 }) )
    let __root = Control.startControl(&builder)
    Control.add(file: __file, &builder)
    Control.add(weight: obj.weight, &builder)
    Control.add(guidanceStart: obj.guidanceStart, &builder)
    Control.add(guidanceEnd: obj.guidanceEnd, &builder)
    Control.add(noPrompt: obj.noPrompt, &builder)
    Control.add(globalAveragePooling: obj.globalAveragePooling, &builder)
    Control.add(downSamplingRate: obj.downSamplingRate, &builder)
    Control.add(controlMode: obj.controlMode, &builder)
    Control.addVectorOf(targetBlocks: __targetBlocks, &builder)
    Control.add(inputOverride: obj.inputOverride, &builder)
    return Control.endControl(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.file.p, fieldName: "file", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.weight.p, fieldName: "weight", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.guidanceStart.p, fieldName: "guidanceStart", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.guidanceEnd.p, fieldName: "guidanceEnd", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.noPrompt.p, fieldName: "noPrompt", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.globalAveragePooling.p, fieldName: "globalAveragePooling", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.downSamplingRate.p, fieldName: "downSamplingRate", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.controlMode.p, fieldName: "controlMode", required: false, type: ControlMode.self)
    try _v.visit(field: VTOFFSET.targetBlocks.p, fieldName: "targetBlocks", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.inputOverride.p, fieldName: "inputOverride", required: false, type: ControlInputType.self)
    _v.finish()
  }
}

public class ControlT: NativeObject {

  public var file: String?
  public var weight: Float32
  public var guidanceStart: Float32
  public var guidanceEnd: Float32
  public var noPrompt: Bool
  public var globalAveragePooling: Bool
  public var downSamplingRate: Float32
  public var controlMode: ControlMode
  public var targetBlocks: [String?]
  public var inputOverride: ControlInputType

  public init(_ _t: inout Control) {
    file = _t.file
    weight = _t.weight
    guidanceStart = _t.guidanceStart
    guidanceEnd = _t.guidanceEnd
    noPrompt = _t.noPrompt
    globalAveragePooling = _t.globalAveragePooling
    downSamplingRate = _t.downSamplingRate
    controlMode = _t.controlMode
    targetBlocks = []
    for index in 0..<_t.targetBlocksCount {
        targetBlocks.append(_t.targetBlocks(at: index))
    }
    inputOverride = _t.inputOverride
  }

  public init() {
    weight = 1.0
    guidanceStart = 0.0
    guidanceEnd = 1.0
    noPrompt = false
    globalAveragePooling = true
    downSamplingRate = 1.0
    controlMode = .balanced
    targetBlocks = []
    inputOverride = .unspecified
  }

  public func serialize() -> ByteBuffer { return serialize(type: Control.self) }

}
public struct LoRA: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case file = 4
    case weight = 6
    case mode = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var file: String? { let o = _accessor.offset(VTOFFSET.file.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var fileSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.file.v) }
  public var weight: Float32 { let o = _accessor.offset(VTOFFSET.weight.v); return o == 0 ? 0.6 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var mode: LoRAMode { let o = _accessor.offset(VTOFFSET.mode.v); return o == 0 ? .all : LoRAMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .all }
  public static func startLoRA(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(file: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: file, at: VTOFFSET.file.p) }
  public static func add(weight: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: weight, def: 0.6, at: VTOFFSET.weight.p) }
  public static func add(mode: LoRAMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mode.rawValue, def: 0, at: VTOFFSET.mode.p) }
  public static func endLoRA(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLoRA(
    _ fbb: inout FlatBufferBuilder,
    fileOffset file: Offset = Offset(),
    weight: Float32 = 0.6,
    mode: LoRAMode = .all
  ) -> Offset {
    let __start = LoRA.startLoRA(&fbb)
    LoRA.add(file: file, &fbb)
    LoRA.add(weight: weight, &fbb)
    LoRA.add(mode: mode, &fbb)
    return LoRA.endLoRA(&fbb, start: __start)
  }
  

  public mutating func unpack() -> LoRAT {
    return LoRAT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout LoRAT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout LoRAT) -> Offset {
    let __file: Offset
    if let s = obj.file {
      __file = builder.create(string: s)
    } else {
      __file = Offset()
    }

    let __root = LoRA.startLoRA(&builder)
    LoRA.add(file: __file, &builder)
    LoRA.add(weight: obj.weight, &builder)
    LoRA.add(mode: obj.mode, &builder)
    return LoRA.endLoRA(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.file.p, fieldName: "file", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.weight.p, fieldName: "weight", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: LoRAMode.self)
    _v.finish()
  }
}

public class LoRAT: NativeObject {

  public var file: String?
  public var weight: Float32
  public var mode: LoRAMode

  public init(_ _t: inout LoRA) {
    file = _t.file
    weight = _t.weight
    mode = _t.mode
  }

  public init() {
    weight = 0.6
    mode = .all
  }

  public func serialize() -> ByteBuffer { return serialize(type: LoRA.self) }

}
public struct GenerationConfiguration: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case startWidth = 6
    case startHeight = 8
    case seed = 10
    case steps = 12
    case guidanceScale = 14
    case strength = 16
    case model = 18
    case sampler = 20
    case batchCount = 22
    case batchSize = 24
    case hiresFix = 26
    case hiresFixStartWidth = 28
    case hiresFixStartHeight = 30
    case hiresFixStrength = 32
    case upscaler = 34
    case imageGuidanceScale = 36
    case seedMode = 38
    case clipSkip = 40
    case controls = 42
    case loras = 44
    case maskBlur = 46
    case faceRestoration = 48
    case clipWeight = 54
    case negativePromptForImagePrior = 56
    case imagePriorSteps = 58
    case refinerModel = 60
    case originalImageHeight = 62
    case originalImageWidth = 64
    case cropTop = 66
    case cropLeft = 68
    case targetImageHeight = 70
    case targetImageWidth = 72
    case aestheticScore = 74
    case negativeAestheticScore = 76
    case zeroNegativePrompt = 78
    case refinerStart = 80
    case negativeOriginalImageHeight = 82
    case negativeOriginalImageWidth = 84
    case name = 86
    case fpsId = 88
    case motionBucketId = 90
    case condAug = 92
    case startFrameCfg = 94
    case numFrames = 96
    case maskBlurOutset = 98
    case sharpness = 100
    case shift = 102
    case stage2Steps = 104
    case stage2Cfg = 106
    case stage2Shift = 108
    case tiledDecoding = 110
    case decodingTileWidth = 112
    case decodingTileHeight = 114
    case decodingTileOverlap = 116
    case stochasticSamplingGamma = 118
    case preserveOriginalAfterInpaint = 120
    case tiledDiffusion = 122
    case diffusionTileWidth = 124
    case diffusionTileHeight = 126
    case diffusionTileOverlap = 128
    case upscalerScaleFactor = 130
    case t5TextEncoder = 132
    case separateClipL = 134
    case clipLText = 136
    case separateOpenClipG = 138
    case openClipGText = 140
    case speedUpWithGuidanceEmbed = 142
    case guidanceEmbed = 144
    case resolutionDependentShift = 146
    case teaCacheStart = 148
    case teaCacheEnd = 150
    case teaCacheThreshold = 152
    case teaCache = 154
    case separateT5 = 156
    case t5Text = 158
    case teaCacheMaxSkipSteps = 160
    case causalInferenceEnabled = 162
    case causalInference = 164
    case causalInferencePad = 166
    case cfgZeroStar = 168
    case cfgZeroInitSteps = 170
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: Int64 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var startWidth: UInt16 { let o = _accessor.offset(VTOFFSET.startWidth.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var startHeight: UInt16 { let o = _accessor.offset(VTOFFSET.startHeight.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var seed: UInt32 { let o = _accessor.offset(VTOFFSET.seed.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var steps: UInt32 { let o = _accessor.offset(VTOFFSET.steps.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var guidanceScale: Float32 { let o = _accessor.offset(VTOFFSET.guidanceScale.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var strength: Float32 { let o = _accessor.offset(VTOFFSET.strength.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var model: String? { let o = _accessor.offset(VTOFFSET.model.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var modelSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.model.v) }
  public var sampler: SamplerType { let o = _accessor.offset(VTOFFSET.sampler.v); return o == 0 ? .dpmpp2mkarras : SamplerType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .dpmpp2mkarras }
  public var batchCount: UInt32 { let o = _accessor.offset(VTOFFSET.batchCount.v); return o == 0 ? 1 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var batchSize: UInt32 { let o = _accessor.offset(VTOFFSET.batchSize.v); return o == 0 ? 1 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var hiresFix: Bool { let o = _accessor.offset(VTOFFSET.hiresFix.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var hiresFixStartWidth: UInt16 { let o = _accessor.offset(VTOFFSET.hiresFixStartWidth.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var hiresFixStartHeight: UInt16 { let o = _accessor.offset(VTOFFSET.hiresFixStartHeight.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var hiresFixStrength: Float32 { let o = _accessor.offset(VTOFFSET.hiresFixStrength.v); return o == 0 ? 0.7 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var upscaler: String? { let o = _accessor.offset(VTOFFSET.upscaler.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var upscalerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.upscaler.v) }
  public var imageGuidanceScale: Float32 { let o = _accessor.offset(VTOFFSET.imageGuidanceScale.v); return o == 0 ? 1.5 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var seedMode: SeedMode { let o = _accessor.offset(VTOFFSET.seedMode.v); return o == 0 ? .legacy : SeedMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .legacy }
  public var clipSkip: UInt32 { let o = _accessor.offset(VTOFFSET.clipSkip.v); return o == 0 ? 1 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var hasControls: Bool { let o = _accessor.offset(VTOFFSET.controls.v); return o == 0 ? false : true }
  public var controlsCount: Int32 { let o = _accessor.offset(VTOFFSET.controls.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func controls(at index: Int32) -> Control? { let o = _accessor.offset(VTOFFSET.controls.v); return o == 0 ? nil : Control(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasLoras: Bool { let o = _accessor.offset(VTOFFSET.loras.v); return o == 0 ? false : true }
  public var lorasCount: Int32 { let o = _accessor.offset(VTOFFSET.loras.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func loras(at index: Int32) -> LoRA? { let o = _accessor.offset(VTOFFSET.loras.v); return o == 0 ? nil : LoRA(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var maskBlur: Float32 { let o = _accessor.offset(VTOFFSET.maskBlur.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var faceRestoration: String? { let o = _accessor.offset(VTOFFSET.faceRestoration.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var faceRestorationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.faceRestoration.v) }
  public var clipWeight: Float32 { let o = _accessor.offset(VTOFFSET.clipWeight.v); return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var negativePromptForImagePrior: Bool { let o = _accessor.offset(VTOFFSET.negativePromptForImagePrior.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  public var imagePriorSteps: UInt32 { let o = _accessor.offset(VTOFFSET.imagePriorSteps.v); return o == 0 ? 5 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var refinerModel: String? { let o = _accessor.offset(VTOFFSET.refinerModel.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var refinerModelSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.refinerModel.v) }
  public var originalImageHeight: UInt32 { let o = _accessor.offset(VTOFFSET.originalImageHeight.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var originalImageWidth: UInt32 { let o = _accessor.offset(VTOFFSET.originalImageWidth.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var cropTop: Int32 { let o = _accessor.offset(VTOFFSET.cropTop.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var cropLeft: Int32 { let o = _accessor.offset(VTOFFSET.cropLeft.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var targetImageHeight: UInt32 { let o = _accessor.offset(VTOFFSET.targetImageHeight.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var targetImageWidth: UInt32 { let o = _accessor.offset(VTOFFSET.targetImageWidth.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var aestheticScore: Float32 { let o = _accessor.offset(VTOFFSET.aestheticScore.v); return o == 0 ? 6.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var negativeAestheticScore: Float32 { let o = _accessor.offset(VTOFFSET.negativeAestheticScore.v); return o == 0 ? 2.5 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var zeroNegativePrompt: Bool { let o = _accessor.offset(VTOFFSET.zeroNegativePrompt.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var refinerStart: Float32 { let o = _accessor.offset(VTOFFSET.refinerStart.v); return o == 0 ? 0.7 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var negativeOriginalImageHeight: UInt32 { let o = _accessor.offset(VTOFFSET.negativeOriginalImageHeight.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var negativeOriginalImageWidth: UInt32 { let o = _accessor.offset(VTOFFSET.negativeOriginalImageWidth.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var fpsId: UInt32 { let o = _accessor.offset(VTOFFSET.fpsId.v); return o == 0 ? 5 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var motionBucketId: UInt32 { let o = _accessor.offset(VTOFFSET.motionBucketId.v); return o == 0 ? 127 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var condAug: Float32 { let o = _accessor.offset(VTOFFSET.condAug.v); return o == 0 ? 0.02 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var startFrameCfg: Float32 { let o = _accessor.offset(VTOFFSET.startFrameCfg.v); return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var numFrames: UInt32 { let o = _accessor.offset(VTOFFSET.numFrames.v); return o == 0 ? 14 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var maskBlurOutset: Int32 { let o = _accessor.offset(VTOFFSET.maskBlurOutset.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var sharpness: Float32 { let o = _accessor.offset(VTOFFSET.sharpness.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var shift: Float32 { let o = _accessor.offset(VTOFFSET.shift.v); return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var stage2Steps: UInt32 { let o = _accessor.offset(VTOFFSET.stage2Steps.v); return o == 0 ? 10 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var stage2Cfg: Float32 { let o = _accessor.offset(VTOFFSET.stage2Cfg.v); return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var stage2Shift: Float32 { let o = _accessor.offset(VTOFFSET.stage2Shift.v); return o == 0 ? 1.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var tiledDecoding: Bool { let o = _accessor.offset(VTOFFSET.tiledDecoding.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var decodingTileWidth: UInt16 { let o = _accessor.offset(VTOFFSET.decodingTileWidth.v); return o == 0 ? 10 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var decodingTileHeight: UInt16 { let o = _accessor.offset(VTOFFSET.decodingTileHeight.v); return o == 0 ? 10 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var decodingTileOverlap: UInt16 { let o = _accessor.offset(VTOFFSET.decodingTileOverlap.v); return o == 0 ? 2 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var stochasticSamplingGamma: Float32 { let o = _accessor.offset(VTOFFSET.stochasticSamplingGamma.v); return o == 0 ? 0.3 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var preserveOriginalAfterInpaint: Bool { let o = _accessor.offset(VTOFFSET.preserveOriginalAfterInpaint.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  public var tiledDiffusion: Bool { let o = _accessor.offset(VTOFFSET.tiledDiffusion.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var diffusionTileWidth: UInt16 { let o = _accessor.offset(VTOFFSET.diffusionTileWidth.v); return o == 0 ? 16 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var diffusionTileHeight: UInt16 { let o = _accessor.offset(VTOFFSET.diffusionTileHeight.v); return o == 0 ? 16 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var diffusionTileOverlap: UInt16 { let o = _accessor.offset(VTOFFSET.diffusionTileOverlap.v); return o == 0 ? 2 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var upscalerScaleFactor: UInt8 { let o = _accessor.offset(VTOFFSET.upscalerScaleFactor.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var t5TextEncoder: Bool { let o = _accessor.offset(VTOFFSET.t5TextEncoder.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  public var separateClipL: Bool { let o = _accessor.offset(VTOFFSET.separateClipL.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var clipLText: String? { let o = _accessor.offset(VTOFFSET.clipLText.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var clipLTextSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.clipLText.v) }
  public var separateOpenClipG: Bool { let o = _accessor.offset(VTOFFSET.separateOpenClipG.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var openClipGText: String? { let o = _accessor.offset(VTOFFSET.openClipGText.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var openClipGTextSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.openClipGText.v) }
  public var speedUpWithGuidanceEmbed: Bool { let o = _accessor.offset(VTOFFSET.speedUpWithGuidanceEmbed.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  public var guidanceEmbed: Float32 { let o = _accessor.offset(VTOFFSET.guidanceEmbed.v); return o == 0 ? 3.5 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var resolutionDependentShift: Bool { let o = _accessor.offset(VTOFFSET.resolutionDependentShift.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  public var teaCacheStart: Int32 { let o = _accessor.offset(VTOFFSET.teaCacheStart.v); return o == 0 ? 5 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var teaCacheEnd: Int32 { let o = _accessor.offset(VTOFFSET.teaCacheEnd.v); return o == 0 ? -1 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var teaCacheThreshold: Float32 { let o = _accessor.offset(VTOFFSET.teaCacheThreshold.v); return o == 0 ? 0.06 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var teaCache: Bool { let o = _accessor.offset(VTOFFSET.teaCache.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var separateT5: Bool { let o = _accessor.offset(VTOFFSET.separateT5.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var t5Text: String? { let o = _accessor.offset(VTOFFSET.t5Text.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var t5TextSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.t5Text.v) }
  public var teaCacheMaxSkipSteps: Int32 { let o = _accessor.offset(VTOFFSET.teaCacheMaxSkipSteps.v); return o == 0 ? 3 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var causalInferenceEnabled: Bool { let o = _accessor.offset(VTOFFSET.causalInferenceEnabled.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var causalInference: Int32 { let o = _accessor.offset(VTOFFSET.causalInference.v); return o == 0 ? 3 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var causalInferencePad: Int32 { let o = _accessor.offset(VTOFFSET.causalInferencePad.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var cfgZeroStar: Bool { let o = _accessor.offset(VTOFFSET.cfgZeroStar.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var cfgZeroInitSteps: Int32 { let o = _accessor.offset(VTOFFSET.cfgZeroInitSteps.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startGenerationConfiguration(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 84) }
  public static func add(id: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: id, def: 0, at: VTOFFSET.id.p) }
  public static func add(startWidth: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: startWidth, def: 0, at: VTOFFSET.startWidth.p) }
  public static func add(startHeight: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: startHeight, def: 0, at: VTOFFSET.startHeight.p) }
  public static func add(seed: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: seed, def: 0, at: VTOFFSET.seed.p) }
  public static func add(steps: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: steps, def: 0, at: VTOFFSET.steps.p) }
  public static func add(guidanceScale: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: guidanceScale, def: 0.0, at: VTOFFSET.guidanceScale.p) }
  public static func add(strength: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strength, def: 0.0, at: VTOFFSET.strength.p) }
  public static func add(model: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: model, at: VTOFFSET.model.p) }
  public static func add(sampler: SamplerType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sampler.rawValue, def: 0, at: VTOFFSET.sampler.p) }
  public static func add(batchCount: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: batchCount, def: 1, at: VTOFFSET.batchCount.p) }
  public static func add(batchSize: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: batchSize, def: 1, at: VTOFFSET.batchSize.p) }
  public static func add(hiresFix: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hiresFix, def: false,
   at: VTOFFSET.hiresFix.p) }
  public static func add(hiresFixStartWidth: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hiresFixStartWidth, def: 0, at: VTOFFSET.hiresFixStartWidth.p) }
  public static func add(hiresFixStartHeight: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hiresFixStartHeight, def: 0, at: VTOFFSET.hiresFixStartHeight.p) }
  public static func add(hiresFixStrength: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hiresFixStrength, def: 0.7, at: VTOFFSET.hiresFixStrength.p) }
  public static func add(upscaler: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: upscaler, at: VTOFFSET.upscaler.p) }
  public static func add(imageGuidanceScale: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: imageGuidanceScale, def: 1.5, at: VTOFFSET.imageGuidanceScale.p) }
  public static func add(seedMode: SeedMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: seedMode.rawValue, def: 0, at: VTOFFSET.seedMode.p) }
  public static func add(clipSkip: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: clipSkip, def: 1, at: VTOFFSET.clipSkip.p) }
  public static func addVectorOf(controls: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: controls, at: VTOFFSET.controls.p) }
  public static func addVectorOf(loras: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: loras, at: VTOFFSET.loras.p) }
  public static func add(maskBlur: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maskBlur, def: 0.0, at: VTOFFSET.maskBlur.p) }
  public static func add(faceRestoration: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: faceRestoration, at: VTOFFSET.faceRestoration.p) }
  public static func add(clipWeight: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: clipWeight, def: 1.0, at: VTOFFSET.clipWeight.p) }
  public static func add(negativePromptForImagePrior: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: negativePromptForImagePrior, def: true,
   at: VTOFFSET.negativePromptForImagePrior.p) }
  public static func add(imagePriorSteps: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: imagePriorSteps, def: 5, at: VTOFFSET.imagePriorSteps.p) }
  public static func add(refinerModel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: refinerModel, at: VTOFFSET.refinerModel.p) }
  public static func add(originalImageHeight: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: originalImageHeight, def: 0, at: VTOFFSET.originalImageHeight.p) }
  public static func add(originalImageWidth: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: originalImageWidth, def: 0, at: VTOFFSET.originalImageWidth.p) }
  public static func add(cropTop: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cropTop, def: 0, at: VTOFFSET.cropTop.p) }
  public static func add(cropLeft: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cropLeft, def: 0, at: VTOFFSET.cropLeft.p) }
  public static func add(targetImageHeight: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: targetImageHeight, def: 0, at: VTOFFSET.targetImageHeight.p) }
  public static func add(targetImageWidth: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: targetImageWidth, def: 0, at: VTOFFSET.targetImageWidth.p) }
  public static func add(aestheticScore: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: aestheticScore, def: 6.0, at: VTOFFSET.aestheticScore.p) }
  public static func add(negativeAestheticScore: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: negativeAestheticScore, def: 2.5, at: VTOFFSET.negativeAestheticScore.p) }
  public static func add(zeroNegativePrompt: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: zeroNegativePrompt, def: false,
   at: VTOFFSET.zeroNegativePrompt.p) }
  public static func add(refinerStart: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: refinerStart, def: 0.7, at: VTOFFSET.refinerStart.p) }
  public static func add(negativeOriginalImageHeight: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: negativeOriginalImageHeight, def: 0, at: VTOFFSET.negativeOriginalImageHeight.p) }
  public static func add(negativeOriginalImageWidth: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: negativeOriginalImageWidth, def: 0, at: VTOFFSET.negativeOriginalImageWidth.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(fpsId: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fpsId, def: 5, at: VTOFFSET.fpsId.p) }
  public static func add(motionBucketId: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: motionBucketId, def: 127, at: VTOFFSET.motionBucketId.p) }
  public static func add(condAug: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: condAug, def: 0.02, at: VTOFFSET.condAug.p) }
  public static func add(startFrameCfg: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: startFrameCfg, def: 1.0, at: VTOFFSET.startFrameCfg.p) }
  public static func add(numFrames: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numFrames, def: 14, at: VTOFFSET.numFrames.p) }
  public static func add(maskBlurOutset: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maskBlurOutset, def: 0, at: VTOFFSET.maskBlurOutset.p) }
  public static func add(sharpness: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: sharpness, def: 0.0, at: VTOFFSET.sharpness.p) }
  public static func add(shift: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shift, def: 1.0, at: VTOFFSET.shift.p) }
  public static func add(stage2Steps: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stage2Steps, def: 10, at: VTOFFSET.stage2Steps.p) }
  public static func add(stage2Cfg: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stage2Cfg, def: 1.0, at: VTOFFSET.stage2Cfg.p) }
  public static func add(stage2Shift: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stage2Shift, def: 1.0, at: VTOFFSET.stage2Shift.p) }
  public static func add(tiledDecoding: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tiledDecoding, def: false,
   at: VTOFFSET.tiledDecoding.p) }
  public static func add(decodingTileWidth: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: decodingTileWidth, def: 10, at: VTOFFSET.decodingTileWidth.p) }
  public static func add(decodingTileHeight: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: decodingTileHeight, def: 10, at: VTOFFSET.decodingTileHeight.p) }
  public static func add(decodingTileOverlap: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: decodingTileOverlap, def: 2, at: VTOFFSET.decodingTileOverlap.p) }
  public static func add(stochasticSamplingGamma: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: stochasticSamplingGamma, def: 0.3, at: VTOFFSET.stochasticSamplingGamma.p) }
  public static func add(preserveOriginalAfterInpaint: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: preserveOriginalAfterInpaint, def: true,
   at: VTOFFSET.preserveOriginalAfterInpaint.p) }
  public static func add(tiledDiffusion: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tiledDiffusion, def: false,
   at: VTOFFSET.tiledDiffusion.p) }
  public static func add(diffusionTileWidth: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: diffusionTileWidth, def: 16, at: VTOFFSET.diffusionTileWidth.p) }
  public static func add(diffusionTileHeight: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: diffusionTileHeight, def: 16, at: VTOFFSET.diffusionTileHeight.p) }
  public static func add(diffusionTileOverlap: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: diffusionTileOverlap, def: 2, at: VTOFFSET.diffusionTileOverlap.p) }
  public static func add(upscalerScaleFactor: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: upscalerScaleFactor, def: 0, at: VTOFFSET.upscalerScaleFactor.p) }
  public static func add(t5TextEncoder: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: t5TextEncoder, def: true,
   at: VTOFFSET.t5TextEncoder.p) }
  public static func add(separateClipL: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: separateClipL, def: false,
   at: VTOFFSET.separateClipL.p) }
  public static func add(clipLText: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: clipLText, at: VTOFFSET.clipLText.p) }
  public static func add(separateOpenClipG: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: separateOpenClipG, def: false,
   at: VTOFFSET.separateOpenClipG.p) }
  public static func add(openClipGText: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: openClipGText, at: VTOFFSET.openClipGText.p) }
  public static func add(speedUpWithGuidanceEmbed: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: speedUpWithGuidanceEmbed, def: true,
   at: VTOFFSET.speedUpWithGuidanceEmbed.p) }
  public static func add(guidanceEmbed: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: guidanceEmbed, def: 3.5, at: VTOFFSET.guidanceEmbed.p) }
  public static func add(resolutionDependentShift: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: resolutionDependentShift, def: true,
   at: VTOFFSET.resolutionDependentShift.p) }
  public static func add(teaCacheStart: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: teaCacheStart, def: 5, at: VTOFFSET.teaCacheStart.p) }
  public static func add(teaCacheEnd: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: teaCacheEnd, def: -1, at: VTOFFSET.teaCacheEnd.p) }
  public static func add(teaCacheThreshold: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: teaCacheThreshold, def: 0.06, at: VTOFFSET.teaCacheThreshold.p) }
  public static func add(teaCache: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: teaCache, def: false,
   at: VTOFFSET.teaCache.p) }
  public static func add(separateT5: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: separateT5, def: false,
   at: VTOFFSET.separateT5.p) }
  public static func add(t5Text: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: t5Text, at: VTOFFSET.t5Text.p) }
  public static func add(teaCacheMaxSkipSteps: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: teaCacheMaxSkipSteps, def: 3, at: VTOFFSET.teaCacheMaxSkipSteps.p) }
  public static func add(causalInferenceEnabled: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: causalInferenceEnabled, def: false,
   at: VTOFFSET.causalInferenceEnabled.p) }
  public static func add(causalInference: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: causalInference, def: 3, at: VTOFFSET.causalInference.p) }
  public static func add(causalInferencePad: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: causalInferencePad, def: 0, at: VTOFFSET.causalInferencePad.p) }
  public static func add(cfgZeroStar: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cfgZeroStar, def: false,
   at: VTOFFSET.cfgZeroStar.p) }
  public static func add(cfgZeroInitSteps: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cfgZeroInitSteps, def: 0, at: VTOFFSET.cfgZeroInitSteps.p) }
  public static func endGenerationConfiguration(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGenerationConfiguration(
    _ fbb: inout FlatBufferBuilder,
    id: Int64 = 0,
    startWidth: UInt16 = 0,
    startHeight: UInt16 = 0,
    seed: UInt32 = 0,
    steps: UInt32 = 0,
    guidanceScale: Float32 = 0.0,
    strength: Float32 = 0.0,
    modelOffset model: Offset = Offset(),
    sampler: SamplerType = .dpmpp2mkarras,
    batchCount: UInt32 = 1,
    batchSize: UInt32 = 1,
    hiresFix: Bool = false,
    hiresFixStartWidth: UInt16 = 0,
    hiresFixStartHeight: UInt16 = 0,
    hiresFixStrength: Float32 = 0.7,
    upscalerOffset upscaler: Offset = Offset(),
    imageGuidanceScale: Float32 = 1.5,
    seedMode: SeedMode = .legacy,
    clipSkip: UInt32 = 1,
    controlsVectorOffset controls: Offset = Offset(),
    lorasVectorOffset loras: Offset = Offset(),
    maskBlur: Float32 = 0.0,
    faceRestorationOffset faceRestoration: Offset = Offset(),
    clipWeight: Float32 = 1.0,
    negativePromptForImagePrior: Bool = true,
    imagePriorSteps: UInt32 = 5,
    refinerModelOffset refinerModel: Offset = Offset(),
    originalImageHeight: UInt32 = 0,
    originalImageWidth: UInt32 = 0,
    cropTop: Int32 = 0,
    cropLeft: Int32 = 0,
    targetImageHeight: UInt32 = 0,
    targetImageWidth: UInt32 = 0,
    aestheticScore: Float32 = 6.0,
    negativeAestheticScore: Float32 = 2.5,
    zeroNegativePrompt: Bool = false,
    refinerStart: Float32 = 0.7,
    negativeOriginalImageHeight: UInt32 = 0,
    negativeOriginalImageWidth: UInt32 = 0,
    nameOffset name: Offset = Offset(),
    fpsId: UInt32 = 5,
    motionBucketId: UInt32 = 127,
    condAug: Float32 = 0.02,
    startFrameCfg: Float32 = 1.0,
    numFrames: UInt32 = 14,
    maskBlurOutset: Int32 = 0,
    sharpness: Float32 = 0.0,
    shift: Float32 = 1.0,
    stage2Steps: UInt32 = 10,
    stage2Cfg: Float32 = 1.0,
    stage2Shift: Float32 = 1.0,
    tiledDecoding: Bool = false,
    decodingTileWidth: UInt16 = 10,
    decodingTileHeight: UInt16 = 10,
    decodingTileOverlap: UInt16 = 2,
    stochasticSamplingGamma: Float32 = 0.3,
    preserveOriginalAfterInpaint: Bool = true,
    tiledDiffusion: Bool = false,
    diffusionTileWidth: UInt16 = 16,
    diffusionTileHeight: UInt16 = 16,
    diffusionTileOverlap: UInt16 = 2,
    upscalerScaleFactor: UInt8 = 0,
    t5TextEncoder: Bool = true,
    separateClipL: Bool = false,
    clipLTextOffset clipLText: Offset = Offset(),
    separateOpenClipG: Bool = false,
    openClipGTextOffset openClipGText: Offset = Offset(),
    speedUpWithGuidanceEmbed: Bool = true,
    guidanceEmbed: Float32 = 3.5,
    resolutionDependentShift: Bool = true,
    teaCacheStart: Int32 = 5,
    teaCacheEnd: Int32 = -1,
    teaCacheThreshold: Float32 = 0.06,
    teaCache: Bool = false,
    separateT5: Bool = false,
    t5TextOffset t5Text: Offset = Offset(),
    teaCacheMaxSkipSteps: Int32 = 3,
    causalInferenceEnabled: Bool = false,
    causalInference: Int32 = 3,
    causalInferencePad: Int32 = 0,
    cfgZeroStar: Bool = false,
    cfgZeroInitSteps: Int32 = 0
  ) -> Offset {
    let __start = GenerationConfiguration.startGenerationConfiguration(&fbb)
    GenerationConfiguration.add(id: id, &fbb)
    GenerationConfiguration.add(startWidth: startWidth, &fbb)
    GenerationConfiguration.add(startHeight: startHeight, &fbb)
    GenerationConfiguration.add(seed: seed, &fbb)
    GenerationConfiguration.add(steps: steps, &fbb)
    GenerationConfiguration.add(guidanceScale: guidanceScale, &fbb)
    GenerationConfiguration.add(strength: strength, &fbb)
    GenerationConfiguration.add(model: model, &fbb)
    GenerationConfiguration.add(sampler: sampler, &fbb)
    GenerationConfiguration.add(batchCount: batchCount, &fbb)
    GenerationConfiguration.add(batchSize: batchSize, &fbb)
    GenerationConfiguration.add(hiresFix: hiresFix, &fbb)
    GenerationConfiguration.add(hiresFixStartWidth: hiresFixStartWidth, &fbb)
    GenerationConfiguration.add(hiresFixStartHeight: hiresFixStartHeight, &fbb)
    GenerationConfiguration.add(hiresFixStrength: hiresFixStrength, &fbb)
    GenerationConfiguration.add(upscaler: upscaler, &fbb)
    GenerationConfiguration.add(imageGuidanceScale: imageGuidanceScale, &fbb)
    GenerationConfiguration.add(seedMode: seedMode, &fbb)
    GenerationConfiguration.add(clipSkip: clipSkip, &fbb)
    GenerationConfiguration.addVectorOf(controls: controls, &fbb)
    GenerationConfiguration.addVectorOf(loras: loras, &fbb)
    GenerationConfiguration.add(maskBlur: maskBlur, &fbb)
    GenerationConfiguration.add(faceRestoration: faceRestoration, &fbb)
    GenerationConfiguration.add(clipWeight: clipWeight, &fbb)
    GenerationConfiguration.add(negativePromptForImagePrior: negativePromptForImagePrior, &fbb)
    GenerationConfiguration.add(imagePriorSteps: imagePriorSteps, &fbb)
    GenerationConfiguration.add(refinerModel: refinerModel, &fbb)
    GenerationConfiguration.add(originalImageHeight: originalImageHeight, &fbb)
    GenerationConfiguration.add(originalImageWidth: originalImageWidth, &fbb)
    GenerationConfiguration.add(cropTop: cropTop, &fbb)
    GenerationConfiguration.add(cropLeft: cropLeft, &fbb)
    GenerationConfiguration.add(targetImageHeight: targetImageHeight, &fbb)
    GenerationConfiguration.add(targetImageWidth: targetImageWidth, &fbb)
    GenerationConfiguration.add(aestheticScore: aestheticScore, &fbb)
    GenerationConfiguration.add(negativeAestheticScore: negativeAestheticScore, &fbb)
    GenerationConfiguration.add(zeroNegativePrompt: zeroNegativePrompt, &fbb)
    GenerationConfiguration.add(refinerStart: refinerStart, &fbb)
    GenerationConfiguration.add(negativeOriginalImageHeight: negativeOriginalImageHeight, &fbb)
    GenerationConfiguration.add(negativeOriginalImageWidth: negativeOriginalImageWidth, &fbb)
    GenerationConfiguration.add(name: name, &fbb)
    GenerationConfiguration.add(fpsId: fpsId, &fbb)
    GenerationConfiguration.add(motionBucketId: motionBucketId, &fbb)
    GenerationConfiguration.add(condAug: condAug, &fbb)
    GenerationConfiguration.add(startFrameCfg: startFrameCfg, &fbb)
    GenerationConfiguration.add(numFrames: numFrames, &fbb)
    GenerationConfiguration.add(maskBlurOutset: maskBlurOutset, &fbb)
    GenerationConfiguration.add(sharpness: sharpness, &fbb)
    GenerationConfiguration.add(shift: shift, &fbb)
    GenerationConfiguration.add(stage2Steps: stage2Steps, &fbb)
    GenerationConfiguration.add(stage2Cfg: stage2Cfg, &fbb)
    GenerationConfiguration.add(stage2Shift: stage2Shift, &fbb)
    GenerationConfiguration.add(tiledDecoding: tiledDecoding, &fbb)
    GenerationConfiguration.add(decodingTileWidth: decodingTileWidth, &fbb)
    GenerationConfiguration.add(decodingTileHeight: decodingTileHeight, &fbb)
    GenerationConfiguration.add(decodingTileOverlap: decodingTileOverlap, &fbb)
    GenerationConfiguration.add(stochasticSamplingGamma: stochasticSamplingGamma, &fbb)
    GenerationConfiguration.add(preserveOriginalAfterInpaint: preserveOriginalAfterInpaint, &fbb)
    GenerationConfiguration.add(tiledDiffusion: tiledDiffusion, &fbb)
    GenerationConfiguration.add(diffusionTileWidth: diffusionTileWidth, &fbb)
    GenerationConfiguration.add(diffusionTileHeight: diffusionTileHeight, &fbb)
    GenerationConfiguration.add(diffusionTileOverlap: diffusionTileOverlap, &fbb)
    GenerationConfiguration.add(upscalerScaleFactor: upscalerScaleFactor, &fbb)
    GenerationConfiguration.add(t5TextEncoder: t5TextEncoder, &fbb)
    GenerationConfiguration.add(separateClipL: separateClipL, &fbb)
    GenerationConfiguration.add(clipLText: clipLText, &fbb)
    GenerationConfiguration.add(separateOpenClipG: separateOpenClipG, &fbb)
    GenerationConfiguration.add(openClipGText: openClipGText, &fbb)
    GenerationConfiguration.add(speedUpWithGuidanceEmbed: speedUpWithGuidanceEmbed, &fbb)
    GenerationConfiguration.add(guidanceEmbed: guidanceEmbed, &fbb)
    GenerationConfiguration.add(resolutionDependentShift: resolutionDependentShift, &fbb)
    GenerationConfiguration.add(teaCacheStart: teaCacheStart, &fbb)
    GenerationConfiguration.add(teaCacheEnd: teaCacheEnd, &fbb)
    GenerationConfiguration.add(teaCacheThreshold: teaCacheThreshold, &fbb)
    GenerationConfiguration.add(teaCache: teaCache, &fbb)
    GenerationConfiguration.add(separateT5: separateT5, &fbb)
    GenerationConfiguration.add(t5Text: t5Text, &fbb)
    GenerationConfiguration.add(teaCacheMaxSkipSteps: teaCacheMaxSkipSteps, &fbb)
    GenerationConfiguration.add(causalInferenceEnabled: causalInferenceEnabled, &fbb)
    GenerationConfiguration.add(causalInference: causalInference, &fbb)
    GenerationConfiguration.add(causalInferencePad: causalInferencePad, &fbb)
    GenerationConfiguration.add(cfgZeroStar: cfgZeroStar, &fbb)
    GenerationConfiguration.add(cfgZeroInitSteps: cfgZeroInitSteps, &fbb)
    return GenerationConfiguration.endGenerationConfiguration(&fbb, start: __start)
  }
  

  public mutating func unpack() -> GenerationConfigurationT {
    return GenerationConfigurationT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout GenerationConfigurationT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout GenerationConfigurationT) -> Offset {
    let __model: Offset
    if let s = obj.model {
      __model = builder.create(string: s)
    } else {
      __model = Offset()
    }

    let __upscaler: Offset
    if let s = obj.upscaler {
      __upscaler = builder.create(string: s)
    } else {
      __upscaler = Offset()
    }

    var __controls__: [Offset] = []
    for var i in obj.controls {
      __controls__.append(Control.pack(&builder, obj: &i))
    }
    let __controls = builder.createVector(ofOffsets: __controls__)
    var __loras__: [Offset] = []
    for var i in obj.loras {
      __loras__.append(LoRA.pack(&builder, obj: &i))
    }
    let __loras = builder.createVector(ofOffsets: __loras__)
    let __faceRestoration: Offset
    if let s = obj.faceRestoration {
      __faceRestoration = builder.create(string: s)
    } else {
      __faceRestoration = Offset()
    }

    let __refinerModel: Offset
    if let s = obj.refinerModel {
      __refinerModel = builder.create(string: s)
    } else {
      __refinerModel = Offset()
    }

    let __name: Offset
    if let s = obj.name {
      __name = builder.create(string: s)
    } else {
      __name = Offset()
    }

    let __clipLText: Offset
    if let s = obj.clipLText {
      __clipLText = builder.create(string: s)
    } else {
      __clipLText = Offset()
    }

    let __openClipGText: Offset
    if let s = obj.openClipGText {
      __openClipGText = builder.create(string: s)
    } else {
      __openClipGText = Offset()
    }

    let __t5Text: Offset
    if let s = obj.t5Text {
      __t5Text = builder.create(string: s)
    } else {
      __t5Text = Offset()
    }

    let __root = GenerationConfiguration.startGenerationConfiguration(&builder)
    GenerationConfiguration.add(id: obj.id, &builder)
    GenerationConfiguration.add(startWidth: obj.startWidth, &builder)
    GenerationConfiguration.add(startHeight: obj.startHeight, &builder)
    GenerationConfiguration.add(seed: obj.seed, &builder)
    GenerationConfiguration.add(steps: obj.steps, &builder)
    GenerationConfiguration.add(guidanceScale: obj.guidanceScale, &builder)
    GenerationConfiguration.add(strength: obj.strength, &builder)
    GenerationConfiguration.add(model: __model, &builder)
    GenerationConfiguration.add(sampler: obj.sampler, &builder)
    GenerationConfiguration.add(batchCount: obj.batchCount, &builder)
    GenerationConfiguration.add(batchSize: obj.batchSize, &builder)
    GenerationConfiguration.add(hiresFix: obj.hiresFix, &builder)
    GenerationConfiguration.add(hiresFixStartWidth: obj.hiresFixStartWidth, &builder)
    GenerationConfiguration.add(hiresFixStartHeight: obj.hiresFixStartHeight, &builder)
    GenerationConfiguration.add(hiresFixStrength: obj.hiresFixStrength, &builder)
    GenerationConfiguration.add(upscaler: __upscaler, &builder)
    GenerationConfiguration.add(imageGuidanceScale: obj.imageGuidanceScale, &builder)
    GenerationConfiguration.add(seedMode: obj.seedMode, &builder)
    GenerationConfiguration.add(clipSkip: obj.clipSkip, &builder)
    GenerationConfiguration.addVectorOf(controls: __controls, &builder)
    GenerationConfiguration.addVectorOf(loras: __loras, &builder)
    GenerationConfiguration.add(maskBlur: obj.maskBlur, &builder)
    GenerationConfiguration.add(faceRestoration: __faceRestoration, &builder)
    GenerationConfiguration.add(clipWeight: obj.clipWeight, &builder)
    GenerationConfiguration.add(negativePromptForImagePrior: obj.negativePromptForImagePrior, &builder)
    GenerationConfiguration.add(imagePriorSteps: obj.imagePriorSteps, &builder)
    GenerationConfiguration.add(refinerModel: __refinerModel, &builder)
    GenerationConfiguration.add(originalImageHeight: obj.originalImageHeight, &builder)
    GenerationConfiguration.add(originalImageWidth: obj.originalImageWidth, &builder)
    GenerationConfiguration.add(cropTop: obj.cropTop, &builder)
    GenerationConfiguration.add(cropLeft: obj.cropLeft, &builder)
    GenerationConfiguration.add(targetImageHeight: obj.targetImageHeight, &builder)
    GenerationConfiguration.add(targetImageWidth: obj.targetImageWidth, &builder)
    GenerationConfiguration.add(aestheticScore: obj.aestheticScore, &builder)
    GenerationConfiguration.add(negativeAestheticScore: obj.negativeAestheticScore, &builder)
    GenerationConfiguration.add(zeroNegativePrompt: obj.zeroNegativePrompt, &builder)
    GenerationConfiguration.add(refinerStart: obj.refinerStart, &builder)
    GenerationConfiguration.add(negativeOriginalImageHeight: obj.negativeOriginalImageHeight, &builder)
    GenerationConfiguration.add(negativeOriginalImageWidth: obj.negativeOriginalImageWidth, &builder)
    GenerationConfiguration.add(name: __name, &builder)
    GenerationConfiguration.add(fpsId: obj.fpsId, &builder)
    GenerationConfiguration.add(motionBucketId: obj.motionBucketId, &builder)
    GenerationConfiguration.add(condAug: obj.condAug, &builder)
    GenerationConfiguration.add(startFrameCfg: obj.startFrameCfg, &builder)
    GenerationConfiguration.add(numFrames: obj.numFrames, &builder)
    GenerationConfiguration.add(maskBlurOutset: obj.maskBlurOutset, &builder)
    GenerationConfiguration.add(sharpness: obj.sharpness, &builder)
    GenerationConfiguration.add(shift: obj.shift, &builder)
    GenerationConfiguration.add(stage2Steps: obj.stage2Steps, &builder)
    GenerationConfiguration.add(stage2Cfg: obj.stage2Cfg, &builder)
    GenerationConfiguration.add(stage2Shift: obj.stage2Shift, &builder)
    GenerationConfiguration.add(tiledDecoding: obj.tiledDecoding, &builder)
    GenerationConfiguration.add(decodingTileWidth: obj.decodingTileWidth, &builder)
    GenerationConfiguration.add(decodingTileHeight: obj.decodingTileHeight, &builder)
    GenerationConfiguration.add(decodingTileOverlap: obj.decodingTileOverlap, &builder)
    GenerationConfiguration.add(stochasticSamplingGamma: obj.stochasticSamplingGamma, &builder)
    GenerationConfiguration.add(preserveOriginalAfterInpaint: obj.preserveOriginalAfterInpaint, &builder)
    GenerationConfiguration.add(tiledDiffusion: obj.tiledDiffusion, &builder)
    GenerationConfiguration.add(diffusionTileWidth: obj.diffusionTileWidth, &builder)
    GenerationConfiguration.add(diffusionTileHeight: obj.diffusionTileHeight, &builder)
    GenerationConfiguration.add(diffusionTileOverlap: obj.diffusionTileOverlap, &builder)
    GenerationConfiguration.add(upscalerScaleFactor: obj.upscalerScaleFactor, &builder)
    GenerationConfiguration.add(t5TextEncoder: obj.t5TextEncoder, &builder)
    GenerationConfiguration.add(separateClipL: obj.separateClipL, &builder)
    GenerationConfiguration.add(clipLText: __clipLText, &builder)
    GenerationConfiguration.add(separateOpenClipG: obj.separateOpenClipG, &builder)
    GenerationConfiguration.add(openClipGText: __openClipGText, &builder)
    GenerationConfiguration.add(speedUpWithGuidanceEmbed: obj.speedUpWithGuidanceEmbed, &builder)
    GenerationConfiguration.add(guidanceEmbed: obj.guidanceEmbed, &builder)
    GenerationConfiguration.add(resolutionDependentShift: obj.resolutionDependentShift, &builder)
    GenerationConfiguration.add(teaCacheStart: obj.teaCacheStart, &builder)
    GenerationConfiguration.add(teaCacheEnd: obj.teaCacheEnd, &builder)
    GenerationConfiguration.add(teaCacheThreshold: obj.teaCacheThreshold, &builder)
    GenerationConfiguration.add(teaCache: obj.teaCache, &builder)
    GenerationConfiguration.add(separateT5: obj.separateT5, &builder)
    GenerationConfiguration.add(t5Text: __t5Text, &builder)
    GenerationConfiguration.add(teaCacheMaxSkipSteps: obj.teaCacheMaxSkipSteps, &builder)
    GenerationConfiguration.add(causalInferenceEnabled: obj.causalInferenceEnabled, &builder)
    GenerationConfiguration.add(causalInference: obj.causalInference, &builder)
    GenerationConfiguration.add(causalInferencePad: obj.causalInferencePad, &builder)
    GenerationConfiguration.add(cfgZeroStar: obj.cfgZeroStar, &builder)
    GenerationConfiguration.add(cfgZeroInitSteps: obj.cfgZeroInitSteps, &builder)
    return GenerationConfiguration.endGenerationConfiguration(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.startWidth.p, fieldName: "startWidth", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.startHeight.p, fieldName: "startHeight", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.seed.p, fieldName: "seed", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.steps.p, fieldName: "steps", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.guidanceScale.p, fieldName: "guidanceScale", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.strength.p, fieldName: "strength", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.model.p, fieldName: "model", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sampler.p, fieldName: "sampler", required: false, type: SamplerType.self)
    try _v.visit(field: VTOFFSET.batchCount.p, fieldName: "batchCount", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.batchSize.p, fieldName: "batchSize", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.hiresFix.p, fieldName: "hiresFix", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.hiresFixStartWidth.p, fieldName: "hiresFixStartWidth", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.hiresFixStartHeight.p, fieldName: "hiresFixStartHeight", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.hiresFixStrength.p, fieldName: "hiresFixStrength", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.upscaler.p, fieldName: "upscaler", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.imageGuidanceScale.p, fieldName: "imageGuidanceScale", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.seedMode.p, fieldName: "seedMode", required: false, type: SeedMode.self)
    try _v.visit(field: VTOFFSET.clipSkip.p, fieldName: "clipSkip", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.controls.p, fieldName: "controls", required: false, type: ForwardOffset<Vector<ForwardOffset<Control>, Control>>.self)
    try _v.visit(field: VTOFFSET.loras.p, fieldName: "loras", required: false, type: ForwardOffset<Vector<ForwardOffset<LoRA>, LoRA>>.self)
    try _v.visit(field: VTOFFSET.maskBlur.p, fieldName: "maskBlur", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.faceRestoration.p, fieldName: "faceRestoration", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.clipWeight.p, fieldName: "clipWeight", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.negativePromptForImagePrior.p, fieldName: "negativePromptForImagePrior", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.imagePriorSteps.p, fieldName: "imagePriorSteps", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.refinerModel.p, fieldName: "refinerModel", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.originalImageHeight.p, fieldName: "originalImageHeight", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.originalImageWidth.p, fieldName: "originalImageWidth", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.cropTop.p, fieldName: "cropTop", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.cropLeft.p, fieldName: "cropLeft", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.targetImageHeight.p, fieldName: "targetImageHeight", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.targetImageWidth.p, fieldName: "targetImageWidth", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.aestheticScore.p, fieldName: "aestheticScore", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.negativeAestheticScore.p, fieldName: "negativeAestheticScore", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.zeroNegativePrompt.p, fieldName: "zeroNegativePrompt", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.refinerStart.p, fieldName: "refinerStart", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.negativeOriginalImageHeight.p, fieldName: "negativeOriginalImageHeight", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.negativeOriginalImageWidth.p, fieldName: "negativeOriginalImageWidth", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.fpsId.p, fieldName: "fpsId", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.motionBucketId.p, fieldName: "motionBucketId", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.condAug.p, fieldName: "condAug", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.startFrameCfg.p, fieldName: "startFrameCfg", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.numFrames.p, fieldName: "numFrames", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.maskBlurOutset.p, fieldName: "maskBlurOutset", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.sharpness.p, fieldName: "sharpness", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.shift.p, fieldName: "shift", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.stage2Steps.p, fieldName: "stage2Steps", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.stage2Cfg.p, fieldName: "stage2Cfg", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.stage2Shift.p, fieldName: "stage2Shift", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.tiledDecoding.p, fieldName: "tiledDecoding", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.decodingTileWidth.p, fieldName: "decodingTileWidth", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.decodingTileHeight.p, fieldName: "decodingTileHeight", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.decodingTileOverlap.p, fieldName: "decodingTileOverlap", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.stochasticSamplingGamma.p, fieldName: "stochasticSamplingGamma", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.preserveOriginalAfterInpaint.p, fieldName: "preserveOriginalAfterInpaint", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.tiledDiffusion.p, fieldName: "tiledDiffusion", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.diffusionTileWidth.p, fieldName: "diffusionTileWidth", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.diffusionTileHeight.p, fieldName: "diffusionTileHeight", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.diffusionTileOverlap.p, fieldName: "diffusionTileOverlap", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.upscalerScaleFactor.p, fieldName: "upscalerScaleFactor", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.t5TextEncoder.p, fieldName: "t5TextEncoder", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.separateClipL.p, fieldName: "separateClipL", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.clipLText.p, fieldName: "clipLText", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.separateOpenClipG.p, fieldName: "separateOpenClipG", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.openClipGText.p, fieldName: "openClipGText", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.speedUpWithGuidanceEmbed.p, fieldName: "speedUpWithGuidanceEmbed", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.guidanceEmbed.p, fieldName: "guidanceEmbed", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.resolutionDependentShift.p, fieldName: "resolutionDependentShift", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.teaCacheStart.p, fieldName: "teaCacheStart", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.teaCacheEnd.p, fieldName: "teaCacheEnd", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.teaCacheThreshold.p, fieldName: "teaCacheThreshold", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.teaCache.p, fieldName: "teaCache", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.separateT5.p, fieldName: "separateT5", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.t5Text.p, fieldName: "t5Text", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.teaCacheMaxSkipSteps.p, fieldName: "teaCacheMaxSkipSteps", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.causalInferenceEnabled.p, fieldName: "causalInferenceEnabled", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.causalInference.p, fieldName: "causalInference", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.causalInferencePad.p, fieldName: "causalInferencePad", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.cfgZeroStar.p, fieldName: "cfgZeroStar", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.cfgZeroInitSteps.p, fieldName: "cfgZeroInitSteps", required: false, type: Int32.self)
    _v.finish()
  }
}

public class GenerationConfigurationT: NativeObject {

  public var id: Int64
  public var startWidth: UInt16
  public var startHeight: UInt16
  public var seed: UInt32
  public var steps: UInt32
  public var guidanceScale: Float32
  public var strength: Float32
  public var model: String?
  public var sampler: SamplerType
  public var batchCount: UInt32
  public var batchSize: UInt32
  public var hiresFix: Bool
  public var hiresFixStartWidth: UInt16
  public var hiresFixStartHeight: UInt16
  public var hiresFixStrength: Float32
  public var upscaler: String?
  public var imageGuidanceScale: Float32
  public var seedMode: SeedMode
  public var clipSkip: UInt32
  public var controls: [ControlT?]
  public var loras: [LoRAT?]
  public var maskBlur: Float32
  public var faceRestoration: String?
  public var clipWeight: Float32
  public var negativePromptForImagePrior: Bool
  public var imagePriorSteps: UInt32
  public var refinerModel: String?
  public var originalImageHeight: UInt32
  public var originalImageWidth: UInt32
  public var cropTop: Int32
  public var cropLeft: Int32
  public var targetImageHeight: UInt32
  public var targetImageWidth: UInt32
  public var aestheticScore: Float32
  public var negativeAestheticScore: Float32
  public var zeroNegativePrompt: Bool
  public var refinerStart: Float32
  public var negativeOriginalImageHeight: UInt32
  public var negativeOriginalImageWidth: UInt32
  public var name: String?
  public var fpsId: UInt32
  public var motionBucketId: UInt32
  public var condAug: Float32
  public var startFrameCfg: Float32
  public var numFrames: UInt32
  public var maskBlurOutset: Int32
  public var sharpness: Float32
  public var shift: Float32
  public var stage2Steps: UInt32
  public var stage2Cfg: Float32
  public var stage2Shift: Float32
  public var tiledDecoding: Bool
  public var decodingTileWidth: UInt16
  public var decodingTileHeight: UInt16
  public var decodingTileOverlap: UInt16
  public var stochasticSamplingGamma: Float32
  public var preserveOriginalAfterInpaint: Bool
  public var tiledDiffusion: Bool
  public var diffusionTileWidth: UInt16
  public var diffusionTileHeight: UInt16
  public var diffusionTileOverlap: UInt16
  public var upscalerScaleFactor: UInt8
  public var t5TextEncoder: Bool
  public var separateClipL: Bool
  public var clipLText: String?
  public var separateOpenClipG: Bool
  public var openClipGText: String?
  public var speedUpWithGuidanceEmbed: Bool
  public var guidanceEmbed: Float32
  public var resolutionDependentShift: Bool
  public var teaCacheStart: Int32
  public var teaCacheEnd: Int32
  public var teaCacheThreshold: Float32
  public var teaCache: Bool
  public var separateT5: Bool
  public var t5Text: String?
  public var teaCacheMaxSkipSteps: Int32
  public var causalInferenceEnabled: Bool
  public var causalInference: Int32
  public var causalInferencePad: Int32
  public var cfgZeroStar: Bool
  public var cfgZeroInitSteps: Int32

  public init(_ _t: inout GenerationConfiguration) {
    id = _t.id
    startWidth = _t.startWidth
    startHeight = _t.startHeight
    seed = _t.seed
    steps = _t.steps
    guidanceScale = _t.guidanceScale
    strength = _t.strength
    model = _t.model
    sampler = _t.sampler
    batchCount = _t.batchCount
    batchSize = _t.batchSize
    hiresFix = _t.hiresFix
    hiresFixStartWidth = _t.hiresFixStartWidth
    hiresFixStartHeight = _t.hiresFixStartHeight
    hiresFixStrength = _t.hiresFixStrength
    upscaler = _t.upscaler
    imageGuidanceScale = _t.imageGuidanceScale
    seedMode = _t.seedMode
    clipSkip = _t.clipSkip
    controls = []
    for index in 0..<_t.controlsCount {
        var __v_ = _t.controls(at: index)
        controls.append(__v_?.unpack())
    }
    loras = []
    for index in 0..<_t.lorasCount {
        var __v_ = _t.loras(at: index)
        loras.append(__v_?.unpack())
    }
    maskBlur = _t.maskBlur
    faceRestoration = _t.faceRestoration
    clipWeight = _t.clipWeight
    negativePromptForImagePrior = _t.negativePromptForImagePrior
    imagePriorSteps = _t.imagePriorSteps
    refinerModel = _t.refinerModel
    originalImageHeight = _t.originalImageHeight
    originalImageWidth = _t.originalImageWidth
    cropTop = _t.cropTop
    cropLeft = _t.cropLeft
    targetImageHeight = _t.targetImageHeight
    targetImageWidth = _t.targetImageWidth
    aestheticScore = _t.aestheticScore
    negativeAestheticScore = _t.negativeAestheticScore
    zeroNegativePrompt = _t.zeroNegativePrompt
    refinerStart = _t.refinerStart
    negativeOriginalImageHeight = _t.negativeOriginalImageHeight
    negativeOriginalImageWidth = _t.negativeOriginalImageWidth
    name = _t.name
    fpsId = _t.fpsId
    motionBucketId = _t.motionBucketId
    condAug = _t.condAug
    startFrameCfg = _t.startFrameCfg
    numFrames = _t.numFrames
    maskBlurOutset = _t.maskBlurOutset
    sharpness = _t.sharpness
    shift = _t.shift
    stage2Steps = _t.stage2Steps
    stage2Cfg = _t.stage2Cfg
    stage2Shift = _t.stage2Shift
    tiledDecoding = _t.tiledDecoding
    decodingTileWidth = _t.decodingTileWidth
    decodingTileHeight = _t.decodingTileHeight
    decodingTileOverlap = _t.decodingTileOverlap
    stochasticSamplingGamma = _t.stochasticSamplingGamma
    preserveOriginalAfterInpaint = _t.preserveOriginalAfterInpaint
    tiledDiffusion = _t.tiledDiffusion
    diffusionTileWidth = _t.diffusionTileWidth
    diffusionTileHeight = _t.diffusionTileHeight
    diffusionTileOverlap = _t.diffusionTileOverlap
    upscalerScaleFactor = _t.upscalerScaleFactor
    t5TextEncoder = _t.t5TextEncoder
    separateClipL = _t.separateClipL
    clipLText = _t.clipLText
    separateOpenClipG = _t.separateOpenClipG
    openClipGText = _t.openClipGText
    speedUpWithGuidanceEmbed = _t.speedUpWithGuidanceEmbed
    guidanceEmbed = _t.guidanceEmbed
    resolutionDependentShift = _t.resolutionDependentShift
    teaCacheStart = _t.teaCacheStart
    teaCacheEnd = _t.teaCacheEnd
    teaCacheThreshold = _t.teaCacheThreshold
    teaCache = _t.teaCache
    separateT5 = _t.separateT5
    t5Text = _t.t5Text
    teaCacheMaxSkipSteps = _t.teaCacheMaxSkipSteps
    causalInferenceEnabled = _t.causalInferenceEnabled
    causalInference = _t.causalInference
    causalInferencePad = _t.causalInferencePad
    cfgZeroStar = _t.cfgZeroStar
    cfgZeroInitSteps = _t.cfgZeroInitSteps
  }

  public init() {
    id = 0
    startWidth = 0
    startHeight = 0
    seed = 0
    steps = 0
    guidanceScale = 0.0
    strength = 0.0
    sampler = .dpmpp2mkarras
    batchCount = 1
    batchSize = 1
    hiresFix = false
    hiresFixStartWidth = 0
    hiresFixStartHeight = 0
    hiresFixStrength = 0.7
    imageGuidanceScale = 1.5
    seedMode = .legacy
    clipSkip = 1
    controls = []
    loras = []
    maskBlur = 0.0
    clipWeight = 1.0
    negativePromptForImagePrior = true
    imagePriorSteps = 5
    originalImageHeight = 0
    originalImageWidth = 0
    cropTop = 0
    cropLeft = 0
    targetImageHeight = 0
    targetImageWidth = 0
    aestheticScore = 6.0
    negativeAestheticScore = 2.5
    zeroNegativePrompt = false
    refinerStart = 0.7
    negativeOriginalImageHeight = 0
    negativeOriginalImageWidth = 0
    fpsId = 5
    motionBucketId = 127
    condAug = 0.02
    startFrameCfg = 1.0
    numFrames = 14
    maskBlurOutset = 0
    sharpness = 0.0
    shift = 1.0
    stage2Steps = 10
    stage2Cfg = 1.0
    stage2Shift = 1.0
    tiledDecoding = false
    decodingTileWidth = 10
    decodingTileHeight = 10
    decodingTileOverlap = 2
    stochasticSamplingGamma = 0.3
    preserveOriginalAfterInpaint = true
    tiledDiffusion = false
    diffusionTileWidth = 16
    diffusionTileHeight = 16
    diffusionTileOverlap = 2
    upscalerScaleFactor = 0
    t5TextEncoder = true
    separateClipL = false
    separateOpenClipG = false
    speedUpWithGuidanceEmbed = true
    guidanceEmbed = 3.5
    resolutionDependentShift = true
    teaCacheStart = 5
    teaCacheEnd = -1
    teaCacheThreshold = 0.06
    teaCache = false
    separateT5 = false
    teaCacheMaxSkipSteps = 3
    causalInferenceEnabled = false
    causalInference = 3
    causalInferencePad = 0
    cfgZeroStar = false
    cfgZeroInitSteps = 0
  }

  public func serialize() -> ByteBuffer { return serialize(type: GenerationConfiguration.self) }

}
